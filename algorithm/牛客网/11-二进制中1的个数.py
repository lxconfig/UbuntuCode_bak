
"""
    输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

    假设 int类型只占用1个字节
    原码：就是正常的二进制数据，如：1的原码是 0000 0001
         负数的原码就是将最高位变成符号位，0正1负，如：-1的原码是 1000 0001

    反码：就是将原码中除了符号位外，每一位取反，如：1的反码是 0000 0001
         如： -1的反码是 1111 1110
    
    补码：就是将原码中除了符号位外，每一位取反，再加1，如：1的补码是 0000 0001
         如： -1的补码是 1111 1111
        
    结论：
        正数：原码 = 反码 = 补码

        负数：
            反码 = 原码除符号位外，按位取反
            补码 = 反码 + 1              
"""

"""
    运行时间：27ms
    占用内存：5752k
"""


class Solution:
    def NumberOf1(self, n):
        # write code here
        '''
        count = 0
        if n == 0:
            return 0
        else:
            # 这步操作的意义在于：python中的数字是没有大小限制的，理论上可以无限扩张。如：-1可能保存为 1111111...n个....1111111
            # 经过这步操作后，可以将负数32位之前数据全部变成0，而后32位不受影响
            # 即 1111111...n个....1111111 & 0000000...n个...ffffffff = 00000000...n个0...1111111(32个1)
            # 0xFFFFFFFF 表示的是后32位
            # 而负数在计算机中就是以补码存放的,这样操作也把负数变为了正数
            # https://blog.csdn.net/xgyyxs/article/details/104697763
            n = 0xFFFFFFFF & n
            binary_n = "{:04b}".format(n)
            # binary_n = str(bin(n))
            for i in binary_n:
                if i == "1":
                    count += 1
        return count
        '''
        # 运行时间：22ms  占用内存：5752k
        count = 0
        n = 0xFFFFFFFF & n
        while n:
            # 当一个二进制数-1时，这个二进制数会有三点变化：(1)最右边的1变为0  (2)最右边的1后面的0都会变成1  (3)最右边的1前面的数不受影响
            # 如：1100 - 0001 = 1011
            # 此时再让 这个二进制数 & 减1后的数会发现：就是把那个最右边的1变为了0
            # 如：1100 & 1011 = 1000
            # 所以，要计算一个二进制数中有多少个1，就是进行过多少次上面的操作
            n = n & (n-1)
            count += 1
        return count


if __name__ == "__main__":
    solution = Solution()
    print(solution.NumberOf1(-1))